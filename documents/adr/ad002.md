# ADR 002 – Adoção do Padrão CQRS (Command Query Responsibility Segregation)
## Contexto

Conforme definido no **ADR 001**, o Sistema de Cinema foi arquitetado em **microsserviços** para permitir independência e escalabilidade. No entanto, analisando os requisitos de negócio, identificou-se uma assimetria significativa entre as operações de leitura e escrita em determinados domínios:

- **Serviço de Filmes (catalog-service):** Sofre uma carga massiva de leituras (usuários navegando no app, buscando filmes), mas possui poucas escritas.
- **Serviço de Sessões e Salas (session-service):** Exige consultas rápidas para verificar disponibilidade de assentos em tempo real, enquanto as escritas (bloqueio de assento) exigem alta consistência.
- **Serviço de Ingressos (ticket-service):** Durante picos de estreia, há alta concorrência de escrita e simultaneamente alta demanda de leitura para validação.

No modelo tradicional (CRUD), utilizar o mesmo modelo de dados para escrita (que exige normalização) e para leitura (que exige performance) pode criar gargalos e acoplamento desnecessário.

Diante desses fatores, é necessário definir uma estratégia para otimizar a performance de leitura sem comprometer a integridade das regras de negócio.

## Decisão

Optou-se por adotar o padrão **CQRS (Command Query Responsibility Segregation)** em serviços críticos do sistema.

Essa decisão implica na separação explícita entre o modelo de escrita (**Command**) e o modelo de leitura (**Query**).

### Aplicação nos Serviços:

- **Serviço de Filmes (Catálogo):**
    - **Command (Escrita):** Responsável por criar/editar filmes. Foca na integridade. Persistência em banco relacional.
    - **Query (Leitura):** Responsável por alimentar a interface. Lerá de uma base otimizada, permitindo consultas rápidas.

- **Serviço de Sessões:**
    - **Command (Escrita):** Processa regras de reserva de assento. Gera eventos de domínio.
    - **Query (Leitura):** Consome eventos para manter uma visualização atualizada da disponibilidade da sala.

A sincronização entre os modelos ocorrerá via **mensageria assíncrona** (RabbitMQ), conforme estabelecido na arquitetura base do sistema.

## Consequências

### Positivas

- **Otimização de Performance:** Permite escalar os bancos de dados de leitura e escrita independentemente.
- **Consultas Simplificadas:** O modelo de leitura pode armazenar DTOs prontos para a tela, eliminando *joins* complexos.
- **Segurança:** Separação clara entre operações que alteram dados e operações que apenas leem.
- **Preservação do Domínio:** O modelo de escrita foca puramente na lógica de negócio (DDD) sem se preocupar com a apresentação.

### Negativas

- **Consistência Eventual:** Haverá um pequeno atraso (latência) entre a gravação de um dado e sua disponibilidade para leitura.
- **Aumento da Complexidade:** Necessidade de gerenciar modelos duplicados e sincronização via eventos.
- **Curva de Aprendizado:** A equipe precisa estar familiarizada com tratamento de falhas na sincronização de projeções.

## Alternativas Consideradas

### 1. Modelo CRUD Tradicional (Único Banco)
**Prós:** Simplicidade de implementação, consistência imediata (ACID).
**Contras:** Gargalo de performance em cenários de alta leitura; difícil escalar apenas um lado da operação.

### 2. Views Materializadas no Banco de Dados
**Prós:** Melhora a performance de leitura mantendo um único banco físico.
**Contras:** Acopla a tecnologia de leitura à de escrita; consome recursos do mesmo servidor.

As alternativas acima não atendem adequadamente à necessidade de alta performance de leitura isolada das regras de escrita complexas.

## Decisão Final

A adoção de **CQRS** foi escolhida para garantir que o sistema suporte picos de acesso no catálogo e na verificação de assentos, mantendo a integridade das transações de negócio no modelo de escrita.

## Data
05 de dezembro de 2025.